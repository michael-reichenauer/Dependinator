using DependinatorCore.Parsing.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

namespace DependinatorCore.Parsing.Sources;

[Transient]
class SourceParser : ISourceParser
{
    static SymbolDisplayFormat MemberFormat = new(
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        memberOptions: SymbolDisplayMemberOptions.IncludeParameters,
        parameterOptions: SymbolDisplayParameterOptions.IncludeType,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes
            | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
    );

    public async Task<R<IReadOnlyList<Parsing.Item>>> ParseSolutionAsync(string slnPath, bool isSkipTests = true)
    {
        MSBuildLocatorHelper.Register();
        using var workspace = MSBuildWorkspace.Create();

        var solution = await workspace.OpenSolutionAsync(slnPath);

        var projects = solution
            .Projects.Where(p => p.Language == LanguageNames.CSharp)
            .Where(p => !IsTestProject(p) || !isSkipTests);

        var parseProjectTasks = projects.Select(ParseProjectAsync);

        List<Parsing.Item> solutionNodes = [];
        await foreach (var parseProjectTask in Task.WhenEach(parseProjectTasks))
        {
            if (!Try(out var items, out var e, await parseProjectTask))
                continue;
            solutionNodes.AddRange(items);
        }

        return solutionNodes;
    }

    public async Task<R<IReadOnlyList<Parsing.Item>>> ParseProjectAsync(string projectPath)
    {
        MSBuildLocatorHelper.Register();
        using var workspace = MSBuildWorkspace.Create();

        var project = await workspace.OpenProjectAsync(projectPath);
        return await ParseProjectAsync(project);
    }

    public async Task<R<IReadOnlyList<Parsing.Item>>> ParseProjectAsync(Project project)
    {
        if (!Try(out var compilation, out var e, await GetCompilationAsync(project)))
            return e;

        return ParseProjectCompilation(compilation).ToList();
    }

    static async Task<R<Compilation>> GetCompilationAsync(Project project)
    {
        var compilation = await project.GetCompilationAsync();
        if (compilation is null)
            return R.Error($"No compilation (project may not be supported/loaded) for {project.FilePath}.");

        var diagnostics = compilation.GetDiagnostics();
        var errors = diagnostics
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .OrderBy(d => d.Location.IsInSource ? d.Location.GetLineSpan().Path : "")
            .ThenBy(d => d.Location.IsInSource ? d.Location.GetLineSpan().StartLinePosition.Line : int.MaxValue)
            .ToArray();

        foreach (var error in errors)
            Log.Warn($"Source Error: {error}");

        return compilation;
    }

    static IEnumerable<Parsing.Item> ParseProjectCompilation(Compilation compilation)
    {
        var moduleName = compilation.AssemblyName?.Replace(".", "*")!;

        foreach (var type in GetAllNamedTypes(compilation.Assembly.GlobalNamespace).Where(t => !t.IsImplicitlyDeclared))
        {
            foreach (var item in ParseType(type, moduleName))
                yield return item;
        }
    }

    private static IEnumerable<Parsing.Item> ParseType(INamedTypeSymbol type, string moduleName)
    {
        var fullTypeName = GetFullTypeName(type, moduleName);
        if (fullTypeName.EndsWith("AutoGeneratedProgram"))
            yield break;

        var typeSpans = GetLocationSpans(type);
        var fileSpan = typeSpans.Any()
            ? new FileSpan(
                typeSpans.First().Path,
                typeSpans.First().StartLinePosition.Line,
                typeSpans.First().EndLinePosition.Line
            )
            : NoValue.FileSpan;

        var typeComment = TypeCommentExtractor.GetTypeComment(type, typeSpans.FirstOrDefault()) ?? NoValue.String;
        yield return new Parsing.Item(
            new Node(fullTypeName, new NodeAttributes { Description = typeComment, FileSpan = fileSpan }),
            null
        );

        // foreach (var member in type.GetMembers().Where(m => !m.IsImplicitlyDeclared))
        // {
        //     // only members declared on this type (not inherited)
        //     if (!SymbolEqualityComparer.Default.Equals(member.ContainingType, type))
        //         continue;
        //     if (member is INamedTypeSymbol)
        //         continue; // Nested type, handled above

        //     var memberSpans = GetLocationSpans(type);
        //     if (!memberSpans.Any())
        //         continue;
        //     var firstMemberSpan = typeSpans.First();

        //     yield return new Parsing.Item(
        //         new Node(
        //             GetFullMemberName(member, fullTypeName),
        //             new NodeAttributes
        //             {
        //                 FileSpan = new FileSpan(
        //                     firstMemberSpan.Path,
        //                     firstMemberSpan.StartLinePosition.Line,
        //                     firstMemberSpan.EndLinePosition.Line
        //                 ),
        //             }
        //         ),
        //         null
        //     );
        // }
    }

    static string GetFullTypeName(ISymbol typeSymbol, string moduleName)
    {
        var fqTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var fullName = fqTypeName.TrimPrefix("global::").Replace("&", "").Replace(" ", "");
        return $"{moduleName}.{fullName}";
    }

    static string GetFullMemberName(ISymbol typeSymbol, string typeName)
    {
        var memberName = typeSymbol.ToDisplayString(MemberFormat);
        return $"{typeName}.{memberName}";
    }

    static IEnumerable<FileLinePositionSpan> GetLocationSpans(INamedTypeSymbol typeSymbol)
    {
        var typeSpans = GetTypeDeclarationSpans(typeSymbol);
        if (typeSpans.Any())
            return typeSpans;
        return GetTypeLocationSpans(typeSymbol);
    }

    static IEnumerable<FileLinePositionSpan> GetTypeDeclarationSpans(INamedTypeSymbol typeSymbol)
    {
        foreach (var syntaxRef in typeSymbol.DeclaringSyntaxReferences)
        {
            var syntax = syntaxRef.GetSyntax();
            if (syntax is TypeDeclarationSyntax typeDecl)
            {
                yield return typeDecl.GetLocation().GetLineSpan();
            }
            else if (syntax is BaseTypeDeclarationSyntax baseTypeDecl)
            {
                yield return baseTypeDecl.GetLocation().GetLineSpan();
            }
        }
    }

    static IEnumerable<FileLinePositionSpan> GetTypeLocationSpans(INamedTypeSymbol typeSymbol)
    {
        foreach (var location in typeSymbol.Locations.Where(l => l.IsInSource))
        {
            yield return location.GetLineSpan();
        }
    }

    static IEnumerable<INamedTypeSymbol> GetAllNamedTypes(INamespaceSymbol ns)
    {
        foreach (var member in ns.GetMembers())
        {
            if (member is INamespaceSymbol childNs)
            {
                foreach (var t in GetAllNamedTypes(childNs))
                    yield return t;
            }
            else if (member is INamedTypeSymbol namedType)
            {
                foreach (var t in GetAllNamedTypes(namedType))
                    yield return t;
            }
        }
    }

    static IEnumerable<INamedTypeSymbol> GetAllNamedTypes(INamedTypeSymbol type)
    {
        yield return type;

        foreach (var nested in type.GetTypeMembers())
        {
            foreach (var t in GetAllNamedTypes(nested))
                yield return t;
        }
    }

    static bool IsTestProject(Project project) => project.Name.EndsWith("Test") || project.Name.EndsWith(".Tests");
}
