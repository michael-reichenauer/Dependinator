using Microsoft.CodeAnalysis;

namespace DependinatorCore.Parsing.Sources;

static class TypeParser
{
    public static IEnumerable<Parsing.Item> ParseType(INamedTypeSymbol type, string moduleName)
    {
        var fullTypeName = Names.GetFullTypeName(type, moduleName);
        if (fullTypeName.EndsWith("AutoGeneratedProgram"))
            yield break;

        var typeSpans = Locations.GetLocationSpans(type);
        var fileSpan = typeSpans.Any()
            ? new FileSpan(
                typeSpans.First().Path,
                typeSpans.First().StartLinePosition.Line,
                typeSpans.First().EndLinePosition.Line
            )
            : NoValue.FileSpan;

        var typeComment = TypeCommentExtractor.GetTypeComment(type, typeSpans.FirstOrDefault()) ?? NoValue.String;
        yield return new Parsing.Item(
            new Node(fullTypeName, new NodeAttributes { Description = typeComment, FileSpan = fileSpan }),
            null
        );

        foreach (ISymbol member in type.GetMembers().Where(m => !m.IsImplicitlyDeclared))
        {
            if (!SymbolEqualityComparer.Default.Equals(member.ContainingType, type))
                yield break;
            if (member is INamedTypeSymbol)
                yield break; // Nested type, handled by SourceParser and TypeParser

            foreach (var item in MemberParser.ParseMember(member, fullTypeName))
                yield return item;
        }
    }
}
