using Microsoft.CodeAnalysis;

namespace DependinatorCore.Parsing.Sources.Roslyn;

static class TypeParser
{
    public static IEnumerable<Item> ParseType(INamedTypeSymbol type, string moduleName)
    {
        var fullTypeName = Names.GetFullTypeName(type, moduleName);
        if (fullTypeName.EndsWith("AutoGeneratedProgram"))
            yield break;

        var fileSpan = Locations.GetFirstFileSpanOrNoValue(type);
        var leadingComment = CommentExtractor.GetLeadingCommentOrNoValue(type, fileSpan);

        yield return new Item(
            new Node(
                fullTypeName,
                new NodeAttributes
                {
                    Type = NodeType.Type,
                    Description = leadingComment,
                    FileSpan = fileSpan,
                }
            ),
            null
        );

        foreach (var item in ParseTypeLinks(type, fullTypeName, moduleName))
            yield return item;

        foreach (var item in ParseTypeMembers(type, fullTypeName))
            yield return item;
    }

    static IEnumerable<Item> ParseTypeLinks(INamedTypeSymbol type, string fullTypeName, string moduleName)
    {
        var links = new List<Item>();

        try
        {
            if (type.BaseType is { } baseType && baseType.SpecialType != SpecialType.System_Object)
                links.Add(ParseTypeLink(fullTypeName, Names.GetFullTypeName(baseType, moduleName)));

            foreach (var interfaceType in type.Interfaces)
                links.Add(ParseTypeLink(fullTypeName, Names.GetFullTypeName(interfaceType, moduleName)));
        }
        catch (Exception e)
        {
            Log.Exception(e, $"Failed to add base type for {type} in {fullTypeName}");
        }

        foreach (var link in links)
            yield return link;
    }

    static Item ParseTypeLink(string sourceTypeName, string targetTypeName)
    {
        var link = new Link(sourceTypeName, targetTypeName, new LinkAttributes { TargetType = NodeType.Type });
        return new Item(null, link);
    }

    static IEnumerable<Item> ParseTypeMembers(INamedTypeSymbol type, string fullTypeName)
    {
        foreach (ISymbol member in type.GetMembers().Where(m => !m.IsImplicitlyDeclared))
        {
            if (!SymbolEqualityComparer.Default.Equals(member.ContainingType, type))
                yield break;
            if (member is INamedTypeSymbol)
                yield break; // Nested type, handled by GetAllNamedTypes in SourceParser

            foreach (var item in MemberParser.ParseTypeMember(member, fullTypeName))
                yield return item;
        }
    }
}
