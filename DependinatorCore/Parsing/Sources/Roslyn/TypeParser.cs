using Microsoft.CodeAnalysis;

namespace DependinatorCore.Parsing.Sources;

static class TypeParser
{
    public static IEnumerable<Parsing.Item> ParseType(INamedTypeSymbol type, string moduleName)
    {
        var fullTypeName = Names.GetFullTypeName(type, moduleName);
        if (fullTypeName.EndsWith("AutoGeneratedProgram"))
            yield break;

        var fileSpan = Locations.GetFirstFileSpanOrNoValue(type);
        var leadingComment = CommentExtractor.GetLeadingCommentOrNoValue(type, fileSpan);

        yield return new Parsing.Item(
            new Node(
                fullTypeName,
                new NodeAttributes
                {
                    Type = NodeType.Type,
                    Description = leadingComment,
                    FileSpan = fileSpan,
                }
            ),
            null
        );

        foreach (var item in ParseTypeMembers(type, fullTypeName))
            yield return item;
    }

    static IEnumerable<Parsing.Item> ParseTypeMembers(INamedTypeSymbol type, string fullTypeName)
    {
        foreach (ISymbol member in type.GetMembers().Where(m => !m.IsImplicitlyDeclared))
        {
            if (!SymbolEqualityComparer.Default.Equals(member.ContainingType, type))
                yield break;
            if (member is INamedTypeSymbol)
                yield break; // Nested type, handled by GetAllNamedTypes in SourceParser

            foreach (var item in MemberParser.ParseTypeMember(member, fullTypeName))
                yield return item;
        }
    }
}
