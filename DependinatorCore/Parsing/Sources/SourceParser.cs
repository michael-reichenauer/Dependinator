#if !BROWSER_WASM
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;
#endif

namespace DependinatorCore.Parsing.Sources;

interface ISourceParser
{
    Task<R<IReadOnlyList<Parsing.Item>>> ParseAsync(string slnPath);
}

#if BROWSER_WASM
[Transient]
class SourceParser : ISourceParser
{
    public Task<R<IReadOnlyList<Parsing.Item>>> ParseAsync(string slnPath)
    {
        return Task.FromResult<R<IReadOnlyList<Parsing.Item>>>(
            R.Error($"Source parsing is not supported in browser runtime: {slnPath}.")
        );
    }
}
#else
[Transient]
class SourceParser : ISourceParser
{
    public async Task<R<IReadOnlyList<Parsing.Item>>> ParseAsync(string slnPath)
    {
        MSBuildLocatorHelper.Register();
        using var workspace = MSBuildWorkspace.Create();

        var solution = await workspace.OpenSolutionAsync(slnPath);
        var projects = solution
            .Projects.Where(p => p.Language == LanguageNames.CSharp)
            .Where(p => !IsTestProject(p))
            .ToList();

        var projectNodesTasks = projects.Select(async project =>
        {
            if (!Try(out var compilation, out var e, await GetCompilationAsync(project)))
                return e;

            return GetNodesAsync(compilation);
        });

        List<Parsing.Item> solutionNodes = [];
        await foreach (var nodesTasks in Task.WhenEach(projectNodesTasks))
        {
            if (!Try(out var projectNodes, out var e, await nodesTasks))
                continue;
            solutionNodes.AddRange(projectNodes);
        }
        return solutionNodes;
    }

    bool IsTestProject(Project project)
    {
        return project.Name.EndsWith("Test") || project.Name.EndsWith(".Tests");
    }

    static async Task<R<Compilation>> GetCompilationAsync(Project project)
    {
        var compilation = await project.GetCompilationAsync();
        if (compilation is null)
            return R.Error($"No compilation (project may not be supported/loaded) for {project.FilePath}.");

        var diagnostics = compilation.GetDiagnostics();
        var errors = diagnostics
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .OrderBy(d => d.Location.IsInSource ? d.Location.GetLineSpan().Path : "")
            .ThenBy(d => d.Location.IsInSource ? d.Location.GetLineSpan().StartLinePosition.Line : int.MaxValue)
            .ToArray();

        foreach (var error in errors)
            Log.Warn($"Source Error: {error}");

        return compilation;
    }

    R<IReadOnlyList<Parsing.Item>> GetNodesAsync(Compilation compilation)
    {
        var nodeSpans = GetAllNamedTypes(compilation.Assembly.GlobalNamespace)
            .Where(t => !t.IsImplicitlyDeclared)
            .Select(type =>
            {
                var fqTypeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (fqTypeName == "global::AutoGeneratedProgram")
                    return null;

                //var nodeName = NodeName.From(fullName);
                var nodeName = GetTypeFullName(fqTypeName, compilation);

                var spans = GetLocationSpans(type);
                if (!spans.Any())
                    return null;
                var firstSpan = spans.First();
                return new Parsing.Item(
                    new Node(
                        nodeName,
                        new NodeAttributes
                        {
                            FileSpan = new FileSpan(
                                firstSpan.Path,
                                firstSpan.StartLinePosition.Line,
                                firstSpan.EndLinePosition.Line
                            ),
                        }
                    ),
                    null
                );
            })
            .Where(nfs => nfs is not null)
            .Cast<Parsing.Item>()
            .ToList();
        return nodeSpans;
    }

    private string GetTypeFullName(string fqTypeName, Compilation compilation)
    {
        var fullName = fqTypeName.TrimPrefix("global::").Replace("&", "");
        var moduleName = compilation.AssemblyName?.Replace(".", "*");
        return $"{moduleName}.{fullName}";
    }

    static IEnumerable<FileLinePositionSpan> GetLocationSpans(INamedTypeSymbol typeSymbol)
    {
        var typeSpans = GetTypeDeclarationSpans(typeSymbol);
        if (typeSpans.Any())
            return typeSpans;
        return GetTypeLocationSpans(typeSymbol);
    }

    static IEnumerable<FileLinePositionSpan> GetTypeDeclarationSpans(INamedTypeSymbol typeSymbol)
    {
        foreach (var syntaxRef in typeSymbol.DeclaringSyntaxReferences)
        {
            var syntax = syntaxRef.GetSyntax();
            if (syntax is TypeDeclarationSyntax typeDecl)
            {
                yield return typeDecl.GetLocation().GetLineSpan();
            }
            else if (syntax is BaseTypeDeclarationSyntax baseTypeDecl)
            {
                yield return baseTypeDecl.GetLocation().GetLineSpan();
            }
        }
    }

    static IEnumerable<FileLinePositionSpan> GetTypeLocationSpans(INamedTypeSymbol typeSymbol)
    {
        foreach (var location in typeSymbol.Locations.Where(l => l.IsInSource))
        {
            yield return location.GetLineSpan();
        }
    }

    static IEnumerable<INamedTypeSymbol> GetAllNamedTypes(INamespaceSymbol ns)
    {
        foreach (var member in ns.GetMembers())
        {
            if (member is INamespaceSymbol childNs)
            {
                foreach (var t in GetAllNamedTypes(childNs))
                    yield return t;
            }
            else if (member is INamedTypeSymbol namedType)
            {
                foreach (var t in GetAllNamedTypes(namedType))
                    yield return t;
            }
        }
    }

    static IEnumerable<INamedTypeSymbol> GetAllNamedTypes(INamedTypeSymbol type)
    {
        yield return type;

        foreach (var nested in type.GetTypeMembers())
        {
            foreach (var t in GetAllNamedTypes(nested))
                yield return t;
        }
    }
}
#endif
