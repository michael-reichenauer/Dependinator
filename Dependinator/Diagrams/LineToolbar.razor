@using Dependinator.Diagrams.Icons
@using Dependinator.Diagrams.Dependencies


@inject IApplicationEvents applicationEvents
@inject IInteractionService interactionService
@inject ISelectionService selectionService
@inject IDialogService dialogService
@inject IDependenciesService dependenciesService
@inject ILineEditService lineEditService

@if (HasSelectedLine)
{
    <MudStack Style="@containerPosition" Spacing="1">
        <MudButtonGroup Color="Color.Tertiary" Size="Size.Small" Variant="Variant.Filled">
            @if (selectionService.IsSelectedLineDirect)
            {
                <MudIconButton Icon="@MudBlazor.Icons.Material.Filled.Close" OnClick="CloseDirectLine" />
                <MudIconButton Icon="@Icon.LineSourceIcon" OnClick="PanToSource" />
                <MudIconButton Icon="@Icon.LineTargetIcon" OnClick="PanToTarget" />
            }
            else
            {
                <MudIconButton Icon="@Icon.ReferencesIcon" OnClick="ShowReferences" />
                <MudIconButton Icon="@Icon.DependenciesIcon" OnClick="ShowDependencies" />
                <MudIconButton Icon="@MudBlazor.Icons.Material.Filled.Add" OnClick="AddSegmentPoint" />
                <MudIconButton Icon="@MudBlazor.Icons.Material.Filled.Remove" OnClick="RemoveSegmentPoint" />
            }
        </MudButtonGroup>
    </MudStack>
}


@code {
    bool HasSelectedLine => selectionService.SelectedLinePosition != Models.Pos.None;

    bool isIcon => !interactionService.IsContainer;
    double left => selectionService.SelectedLinePosition.X;
    double top => selectionService.SelectedLinePosition.Y - 20;
    string containerPosition => $"Position: fixed; left:{left}px; top:{top}px";

    void ShowReferences() => dependenciesService.ShowReferences();
    void ShowDependencies() => dependenciesService.ShowDependencies();
    async Task AddSegmentPoint()
    {
        if (!selectionService.SelectedId.IsLine)
            return;
        await lineEditService.AddSegmentPoint(
            Models.LineId.FromId(selectionService.SelectedId.Id),
            selectionService.SelectedLineClickPosition
        );
    }
    async Task RemoveSegmentPoint()
    {
        if (!selectionService.SelectedId.IsLine)
            return;
        await lineEditService.RemoveSegmentPoint(
            Models.LineId.FromId(selectionService.SelectedId.Id),
            selectionService.SelectedLineClickPosition
        );
    }
    void CloseDirectLine()
    {
        if (!selectionService.SelectedId.IsLine)
            return;
        var lineId = Models.LineId.FromId(selectionService.SelectedId.Id);
        dependenciesService.HideDirectLine(lineId);
    }
    void PanToSource()
    {
        if (!TryGetSelectedLine(out var line))
            return;
        SelectNode(line.Source);
    }

    void PanToTarget()
    {
        if (!TryGetSelectedLine(out var line))
            return;
        SelectNode(line.Target);
    }

    bool TryGetSelectedLine(out Models.Line line)
    {
        line = null!;
        if (!selectionService.SelectedId.IsLine)
            return false;
        var lineId = Models.LineId.FromId(selectionService.SelectedId.Id);
        var found = dependenciesService.TryGetLine(lineId, out line);
        return found && line is not null;
    }

    void SelectNode(Models.Node node)
    {
        applicationEvents.TriggerUIStateChanged();
        dependenciesService.ShowNodeAsync(node.Id);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender) applicationEvents.UIStateChanged += () => InvokeAsync(StateHasChanged);
    }
}
