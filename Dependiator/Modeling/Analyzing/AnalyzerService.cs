using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;


namespace Dependiator.Modeling.Analyzing
{
	internal class AnalyzerService : IAnalyzerService
	{
		internal const BindingFlags DeclaredOnlyFlags =
			BindingFlags.Public | BindingFlags.NonPublic
			| BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly;

		private static readonly char[] DotSeparator = ".".ToCharArray();


		public ElementTree Analyze()
		{
			ElementTree tree = new ElementTree();
			string location = Assembly.GetExecutingAssembly().Location;

			Assembly assembly = Assembly.ReflectionOnlyLoadFrom(location);

			IReadOnlyList<TypeInfo> typeInfos = assembly.DefinedTypes.ToList();

			Dictionary<string, NameSpaceElement> nameSpaces = new Dictionary<string, NameSpaceElement>();
			nameSpaces[tree.Root.FullName] = tree.Root;

			AddTypes(typeInfos, nameSpaces);

			return tree;
		}


		private void AddTypes(
			IReadOnlyList<TypeInfo> typeInfos,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			foreach (TypeInfo typeInfo in typeInfos)
			{
				if (IsCompilerGenerated(typeInfo))
				{
					// Skip types generated by the compiler like e.g. local closures, ...
					continue;
				}

				NameSpaceElement nameSpace = GetOrAddNameSpaceElement(nameSpaces, typeInfo.Namespace);
				TypeElement typeElement = new TypeElement(typeInfo.Name, typeInfo.FullName);
				nameSpace.AddChild(typeElement);

				AddMembers(typeInfo, typeElement, nameSpaces);

				AddBaseTypeReferences(typeInfo, typeElement, nameSpaces);
			}
		}


		private void AddBaseTypeReferences(
			TypeInfo typeInfo, 
			TypeElement typeElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type baseType = typeInfo.BaseType;
			if (baseType != typeof(object))
			{
				AddReferencedTypes(baseType, typeElement, nameSpaces);
			}

			typeInfo.ImplementedInterfaces
				.ForEach(interfaceType => AddReferencedTypes(interfaceType, typeElement, nameSpaces));
		}


		private void AddMembers(
			TypeInfo typeInfo,
			TypeElement typeElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			MemberInfo[] memberInfos = typeInfo.GetMembers(DeclaredOnlyFlags);

			foreach (MemberInfo memberInfo in memberInfos)
			{
				string name = memberInfo.Name;

				string fullName = GetFullName(memberInfo);

				MemberElement memberElement = new MemberElement(name, fullName);
				typeElement.AddChild(memberElement);

				AddReferences(memberInfo, memberElement, nameSpaces);
			}
		}


		private void AddReferences(
			MemberInfo memberInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			if (memberInfo is FieldInfo fieldInfo)
			{
				AddReferencedTypes(fieldInfo, memberElement, nameSpaces);
			}
			else if (memberInfo is PropertyInfo propertyInfo)
			{
				AddReferencedTypes(propertyInfo, memberElement, nameSpaces);
			}
			else if (memberInfo is MethodInfo methodInfo)
			{
				AddReferencedTypes(methodInfo, memberElement, nameSpaces);
			}
		}


		private void AddReferencedTypes(
			FieldInfo fieldInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type fieldType = fieldInfo.FieldType;
			AddReferencedTypes(fieldType, memberElement, nameSpaces);
		}


		private void AddReferencedTypes(
			PropertyInfo propertyInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type propertyType = propertyInfo.PropertyType;
			AddReferencedTypes(propertyType, memberElement, nameSpaces);
		}


		private void AddReferencedTypes(
			MethodInfo methodInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type returnType = methodInfo.ReturnType;
			AddReferencedTypes(returnType, memberElement, nameSpaces);

			methodInfo.GetParameters()
				.Select(parameter => parameter.ParameterType)
				.ForEach(parameterType => AddReferencedTypes(parameterType, memberElement, nameSpaces));

			methodInfo.GetMethodBody()?.LocalVariables
				.Select(variable => variable.LocalType)
				.ForEach(variableType => AddReferencedTypes(variableType, memberElement, nameSpaces));

			// Check https://blogs.msdn.microsoft.com/haibo_luo/2005/10/04/read-il-from-methodbody/
			// byte[] bodyIl = methodBody.GetILAsByteArray();
		}


		private void AddReferencedTypes(
			Type type,
			Element memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			if (type == typeof(void) || type == null)
			{
				// For method return values, the type is void, and e.g. interfaces do not have base type
				return;
			}

			if (type.Namespace != null
			    && (type.Namespace.StartsWith("System", StringComparison.Ordinal)
			        || type.Namespace.StartsWith("Microsoft", StringComparison.Ordinal)))
			{
				// Ignore "System" and "Microsoft" namespaces for now
				return;
			}

			NameSpaceElement nameSpace = GetOrAddNameSpaceElement(nameSpaces, type.Namespace);

			TypeElement typeElement = GetOrAddTypeElement(nameSpace, type);

			Reference reference = new Reference(memberElement, typeElement);
			typeElement.AddReference(reference);

			if (type.IsGenericType)
			{
				type.GetGenericArguments()
					.ForEach(argType => AddReferencedTypes(argType, memberElement, nameSpaces));
			}
		}


		private TypeElement GetOrAddTypeElement(NameSpaceElement nameSpace, Type type)
		{
			TypeElement typeElement = nameSpace.Types.FirstOrDefault(t => t.Name == type.Name);

			if (typeElement == null)
			{
				typeElement = new TypeElement(type.Name, type.FullName);
				nameSpace.AddChild(typeElement);
			}

			return typeElement;
		}


		private NameSpaceElement GetOrAddNameSpaceElement(
			Dictionary<string, NameSpaceElement> nameSpaces, string nameSpaceName)
		{
			string nameSpaceFullName = nameSpaceName ?? "";

			if (!nameSpaces.TryGetValue(nameSpaceFullName, out NameSpaceElement nameSpace))
			{
				nameSpace = CreateNameSpaceElement(nameSpaceFullName, nameSpaces);
			}

			return nameSpace;
		}


		private NameSpaceElement CreateNameSpaceElement(
			string nameSpaceFullName,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			IEnumerable<string> nameSpaceNameFullNames = GetNameSpaceNameFullNames(nameSpaceFullName);

			NameSpaceElement baseNameSpace = nameSpaces[""];

			foreach (string fullName in nameSpaceNameFullNames)
			{
				if (!nameSpaces.TryGetValue(fullName, out NameSpaceElement nameSpace))
				{
					string name = GetNameSpaceNamePart(fullName);
					nameSpace = new NameSpaceElement(name, fullName);

					baseNameSpace.AddChild(nameSpace);
					nameSpaces[fullName] = nameSpace;
				}

				baseNameSpace = nameSpace;
			}

			return baseNameSpace;
		}


		private static string GetFullName(MemberInfo memberInfo)
		{
			return memberInfo.DeclaringType != null
				? memberInfo.DeclaringType.FullName + "." + memberInfo.Name
				: memberInfo.Name;
		}


		private static bool IsCompilerGenerated(TypeInfo typeInfo)
		{
			return typeInfo.Name.IndexOf("<", StringComparison.Ordinal) != -1;
		}


		private IEnumerable<string> GetNameSpaceNameFullNames(string nameSpaceFullName)
		{
			List<string> fullNames = new List<string>();

			// Add global root namespace
			string fullName = "";
			fullNames.Add(fullName);

			string[] parts = nameSpaceFullName.Split(DotSeparator);

			foreach (string part in parts)
			{
				fullName += fullName == "" ? part : "." + part;
				fullNames.Add(fullName);
			}

			return fullNames;
		}


		private string GetNameSpaceNamePart(string nameSpaceFullName)
		{
			int index = nameSpaceFullName.LastIndexOf('.');

			if (index == -1)
			{
				// root namespace
				return nameSpaceFullName;
			}

			return nameSpaceFullName.Substring(index + 1);
		}
	}


	internal class Reference
	{
		public Reference(Element source, Element target)
		{
			Source = source;
			Target = target;
		}


		public Element Source { get; }
		public Element Target { get; }
	}
}