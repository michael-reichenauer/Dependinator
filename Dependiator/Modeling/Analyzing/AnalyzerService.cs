using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;


namespace Dependiator.Modeling.Analyzing
{
	internal class AnalyzerService : IAnalyzerService
	{
		private readonly IElementFactory elementFactory;
		internal const BindingFlags DeclaredOnlyFlags =
			BindingFlags.Public | BindingFlags.NonPublic
			| BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly;

		private static readonly char[] DotSeparator = ".".ToCharArray();


		public AnalyzerService(IElementFactory elementFactory)
		{
			this.elementFactory = elementFactory;
		}

		public ElementTree Analyze()
		{
			NameSpaceElement root = elementFactory.CreateNameSpace(new ElementName("", ""), null);
			ElementTree tree = new ElementTree(root);
			string location = Assembly.GetExecutingAssembly().Location;

			Assembly assembly = Assembly.ReflectionOnlyLoadFrom(location);

			IReadOnlyList<TypeInfo> typeInfos = assembly.DefinedTypes.ToList();

			Dictionary<string, NameSpaceElement> nameSpaces = new Dictionary<string, NameSpaceElement>();
			nameSpaces[tree.Root.Name.FullName] = tree.Root;

			AddTypes(typeInfos, nameSpaces);

			return tree;
		}


		private void AddTypes(
			IReadOnlyList<TypeInfo> typeInfos,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			foreach (TypeInfo typeInfo in typeInfos)
			{
				if (IsCompilerGenerated(typeInfo))
				{
					// Skip types generated by the compiler like e.g. local closures, ...
					continue;
				}

				NameSpaceElement nameSpace = GetOrAddNameSpaceElement(nameSpaces, typeInfo.Namespace);
				ElementName name = new ElementName(typeInfo.Name, typeInfo.FullName);
				TypeElement typeElement = elementFactory.CreateType(name, nameSpace);
				nameSpace.Children.Add(typeElement);

				AddMembers(typeInfo, typeElement, nameSpaces);

				AddBaseTypeReferences(typeInfo, typeElement, nameSpaces);
			}
		}


		private void AddBaseTypeReferences(
			TypeInfo typeInfo, 
			TypeElement typeElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type baseType = typeInfo.BaseType;
			if (baseType != typeof(object))
			{
				AddReferencedTypes(baseType, typeElement, nameSpaces);
			}

			typeInfo.ImplementedInterfaces
				.ForEach(interfaceType => AddReferencedTypes(interfaceType, typeElement, nameSpaces));
		}


		private void AddMembers(
			TypeInfo typeInfo,
			TypeElement typeElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			MemberInfo[] memberInfos = typeInfo.GetMembers(DeclaredOnlyFlags);

			foreach (MemberInfo memberInfo in memberInfos)
			{
				string name = memberInfo.Name;
				string fullName = GetFullName(memberInfo);
				ElementName elementName = new ElementName(name, fullName);
				MemberElement memberElement = elementFactory.CreateMember(elementName, typeElement);
				typeElement.Children.Add(memberElement);

				AddReferences(memberInfo, memberElement, nameSpaces);
			}
		}


		private void AddReferences(
			MemberInfo memberInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			if (
					memberInfo.Name.StartsWith("get")
				|| memberInfo.Name.StartsWith("set")
				|| memberInfo.Name.StartsWith("add_")
				|| memberInfo.Name.StartsWith("remove_"))
			{

			}

			if (memberInfo is FieldInfo fieldInfo)
			{
				AddReferencedTypes(fieldInfo, memberElement, nameSpaces);
			}
			else if (memberInfo is PropertyInfo propertyInfo)
			{
				AddReferencedTypes(propertyInfo, memberElement, nameSpaces);
			}
			else if (memberInfo is EventInfo eventInfo)
			{
				AddReferencedTypes(eventInfo, memberElement, nameSpaces);
			}
			else if (memberInfo is MethodInfo methodInfo)
			{
				AddReferencedTypes(methodInfo, memberElement, nameSpaces);
			}
		}


		private void AddReferencedTypes(
			FieldInfo fieldInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type fieldType = fieldInfo.FieldType;
			AddReferencedTypes(fieldType, memberElement, nameSpaces);
		}


		private void AddReferencedTypes(
			PropertyInfo propertyInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type propertyType = propertyInfo.PropertyType;
			AddReferencedTypes(propertyType, memberElement, nameSpaces);
		}

		private void AddReferencedTypes(
			EventInfo eventInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			Type eventHandlerType = eventInfo.EventHandlerType;
			AddReferencedTypes(eventHandlerType, memberElement, nameSpaces);
		}


		private void AddReferencedTypes(
			MethodInfo methodInfo,
			MemberElement memberElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			if (methodInfo.IsSpecialName)
			{
				if (!(
					methodInfo.Name.StartsWith("get_")
				|| methodInfo.Name.StartsWith("set_")
				|| methodInfo.Name.StartsWith("add_")
				|| methodInfo.Name.StartsWith("remove_")))
				{
					// skipping get,set,add,remove methods for now !!!
					return;
				}				
			}

			Type returnType = methodInfo.ReturnType;
			AddReferencedTypes(returnType, memberElement, nameSpaces);

			methodInfo.GetParameters()
				.Select(parameter => parameter.ParameterType)
				.ForEach(parameterType => AddReferencedTypes(parameterType, memberElement, nameSpaces));

			//methodInfo.GetMethodBody()?.LocalVariables
			//	.Select(variable => variable.LocalType)
			//	.ForEach(variableType => AddReferencedTypes(variableType, memberElement, nameSpaces));

			// Check https://blogs.msdn.microsoft.com/haibo_luo/2005/10/04/read-il-from-methodbody/
			// byte[] bodyIl = methodBody.GetILAsByteArray();
		}


		private void AddReferencedTypes(
			Type targetType,
			Element sourceElement,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			if (targetType == typeof(void) || targetType == null)
			{
				// For method return values, the type is void, and e.g. interfaces do not have base type
				return;
			}

			if (targetType.Namespace != null
			    && (targetType.Namespace.StartsWith("System", StringComparison.Ordinal)
			        || targetType.Namespace.StartsWith("Microsoft", StringComparison.Ordinal)))
			{
				// Ignore "System" and "Microsoft" namespaces for now
				return;
			}

			NameSpaceElement nameSpace = GetOrAddNameSpaceElement(nameSpaces, targetType.Namespace);

			TypeElement targetElement = GetOrAddTypeElement(nameSpace, targetType);

			Reference reference = new Reference(sourceElement, targetElement, ReferenceKind.Direkt);
			sourceElement.References.AddReference(reference);
			targetElement.References.AddReference(reference);

			if (targetType.IsGenericType)
			{
				targetType.GetGenericArguments()
					.ForEach(argType => AddReferencedTypes(argType, sourceElement, nameSpaces));
			}
		}


		private TypeElement GetOrAddTypeElement(NameSpaceElement nameSpace, Type type)
		{
			TypeElement typeElement = nameSpace.Types.FirstOrDefault(t => t.Name.Name == type.Name);

			if (typeElement == null)
			{
				ElementName name = new ElementName(type.Name, type.FullName);
				typeElement = elementFactory.CreateType(name, nameSpace);
				nameSpace.Children.Add(typeElement);
			}

			return typeElement;
		}


		private NameSpaceElement GetOrAddNameSpaceElement(
			Dictionary<string, NameSpaceElement> nameSpaces, string nameSpaceName)
		{
			string nameSpaceFullName = nameSpaceName ?? "";

			if (!nameSpaces.TryGetValue(nameSpaceFullName, out NameSpaceElement nameSpace))
			{
				nameSpace = CreateNameSpaceElement(nameSpaceFullName, nameSpaces);
			}

			return nameSpace;
		}


		private NameSpaceElement CreateNameSpaceElement(
			string nameSpaceFullName,
			Dictionary<string, NameSpaceElement> nameSpaces)
		{
			IEnumerable<string> nameSpaceNameFullNames = GetNameSpaceNameFullNames(nameSpaceFullName);

			NameSpaceElement baseNameSpace = nameSpaces[""];

			foreach (string fullName in nameSpaceNameFullNames)
			{
				if (!nameSpaces.TryGetValue(fullName, out NameSpaceElement nameSpace))
				{
					string name = GetNameSpaceNamePart(fullName);
					ElementName elementName = new ElementName(name, fullName);
					nameSpace = elementFactory.CreateNameSpace(elementName, baseNameSpace);

					baseNameSpace.Children.Add(nameSpace);
					nameSpaces[fullName] = nameSpace;
				}

				baseNameSpace = nameSpace;
			}

			return baseNameSpace;
		}


		private static string GetFullName(MemberInfo memberInfo)
		{
			return memberInfo.DeclaringType != null
				? memberInfo.DeclaringType.FullName + "." + memberInfo.Name
				: memberInfo.Name;
		}


		private static bool IsCompilerGenerated(TypeInfo typeInfo)
		{
			return typeInfo.Name.IndexOf("<", StringComparison.Ordinal) != -1;
		}


		private IEnumerable<string> GetNameSpaceNameFullNames(string nameSpaceFullName)
		{
			List<string> fullNames = new List<string>();

			// Add global root namespace
			string fullName = "";
			fullNames.Add(fullName);

			string[] parts = nameSpaceFullName.Split(DotSeparator);

			foreach (string part in parts)
			{
				fullName += fullName == "" ? part : "." + part;
				fullNames.Add(fullName);
			}

			return fullNames;
		}


		private string GetNameSpaceNamePart(string nameSpaceFullName)
		{
			int index = nameSpaceFullName.LastIndexOf('.');

			if (index == -1)
			{
				// root namespace
				return nameSpaceFullName;
			}

			return nameSpaceFullName.Substring(index + 1);
		}
	}
}